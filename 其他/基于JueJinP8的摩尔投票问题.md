## 定义

**摩尔投票**是一种用来解决**绝对众数**问题的算法。

在一个集合中，如果一个元素的出现次数比其他所有元素的出现次数**之和**还多，那么就称它为这个集合的**==绝对==众数**。等价地说，绝对众数的出现次数大于总元素数的**一半**。

## 过程

我们初始化$m$，当作我们第一个维护的对象，当我们找到绝对众数的时候，可以知道$m$，**如果不是众数，我们要弃之不顾。**判断其是否为众数我们可以通过**唯一**$count$来确定，由于**唯一**，我们可以有判断当$count$为0的时候，进行下一位维护的对象的查找【也就是下一位遍历到的数字】。

| 轮数 | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| m    | 1    | 1    | 3    | 3    | 3    |
| cnt  | 1    | 0    | 1    | 0    | 1    |

有Cpp代码如下:

```cpp
int m = 0, cnt = 0;
for (int i = 0; i < n; ++i)
{
    if (cnt == 0)
        m = A[i];
    if (m == A[i])
        cnt++;
    else
        cnt--;
}
```

但是，我们要判断这个数字是否存在数量大于总数的一半，如果是，这个返回的数值就是答案。

这是因为，在最后计票时，我们知道有 $cnt$ 张票投给了 $m$ ，假如绝对众数另有其人，那么一定是剩下的票投出来的。但剩下的 $n−cnt$ 张票都是在“捉对厮杀”的过程中被抵消掉的，每一对被抵消的票都来自不同的候选人，所以一个候选人最多在这里拿到 $\frac{n−cnt}2$ 票，这不可能大于 $\frac{n}{2}$ 。但绝对众数确实存在，所以这个绝对众数就一定是 $m$ 。

- 时间复杂度$O(n)$
- 空间复杂度$O(1)$



## 拓展摩尔投票

上面的算法是只选出一个人的情形。但其实，如果要选出 $N$ 个候选人，并且要求每个人的得票都超过总票数的$\frac{1}{N+1}$ ，也可以用上面的算法，只需稍微修改即可。

```cpp
int m[N], cnt[N];
for (auto e : nums) {
    int i = find(m, m + N, e) - m;
    if (i != N) { // 如果当前票投给了候选人之一
        cnt[i]++;
        continue;
    }
    int j = find(cnt, cnt + N, 0) - cnt;
    if (j != N) { // 如果当前存在一个位置"虚位以待"
        m[j] = e;
        cnt[j] = 1;
        continue;
    }
    for (auto &c : cnt)
        c--;
}
// 最后需要验证答案是否符合要求
```

原理是一样的。最后我们可以把票分为2个部分：投给了最多 $N$ 个候选人的一部分，和被抵消的一部分。后者可以划分为若干个 $N+1$ 元组，每个元组内的票都来自不同的候选人。因此，只有那些属于第一部分的人的票数可能超过总数的 $\frac{1}{N+1}$ 。



## 区间绝对众数

区间绝对众数问题也可以利用摩尔投票解决，这需要所谓的**线段树上摩尔投票**。

摩尔投票符合结合律吗？实际上并不符合。但是没有关系，因为我们其实只关心 m 而不关心 cnt ，而**当绝对众数存在时，可以任意交换摩尔投票的计票顺序，而不改变选出的候选人**。这是显然的，因为我们上面对摩尔投票的原理的分析完全不依赖于顺序。

所以，我们可以在线段树上进行摩尔投票。在合并左右两个区间时，相当于是先对左右两边分别进行摩尔投票，再对两边抵消后的结果进行摩尔投票。具体地，我们维护下面这样的节点：

```cpp
struct Node
{
    int m, cnt;
    Node operator+(const Node &o) const
    {
        if (m == o.m)
            return {m, cnt + o.cnt};
        else if (cnt > o.cnt)
            return {m, cnt - o.cnt};
        else
            return {o.m, o.cnt - cnt};
    }
};
```

然后用写一个支持区间求和的（递归/非递归式）线段树即可。

不过，我们已经知道用摩尔投票求绝对众数需要验证，现在我们需要对若干个区间的询问快速进行验证，这样怎样实现呢？其实，对每个权值预处理一个下标数组，然后二分查找即可。

例如，对于数组 $⟨2,3,2,2,3,2,1⟩$ ，我们要验证 2 是不是区间 $[2,6]$ 里的绝对众数，于是我们考察 2 的下标数组 $⟨1,3,4,6⟩$ ，发现满足 $2≤x≤6$ 的 x 一共有 3 个（这个用二分查找即可实现），出现次数超过区间长度的一半，所以就是绝对众数。

```cpp
// vector<int> pos[MAXV];
// pos[m]表示权值m的下标数组，需要预处理
// 如果权值值域过大，需要改用map或哈希表
auto itr = upper_bound(pos[m].begin(), pos[m].end(), right);
auto itl = lower_bound(pos[m].begin(), pos[m].end(), left);
if (itr - itl > (right - left + 1) / 3)
    return m;
else
    return -1;
```