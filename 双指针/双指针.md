# 双指针

## 写在开头的话
双指针的思想在很多算法中都有应用，但是双指针的分类很多，也很容易混淆，这里我就把双指针的分类和应用场景总结一下。

## 双指针的分类
双指针的分类有很多，但是我这里只讲两种，一种是快慢指针，一种是左右指针（一个更细分的分支是滑动窗口）。

### 快慢指针
快慢指针是指两个指针从同一个起点出发，但是一个指针每次走一步，另一个指针每次走两步。这种指针的应用场景有很多，比如判断链表是否有环，判断链表的中点，判断链表的倒数第k个节点等等。
在使用快慢指针（也称为“龟兔赛跑”指针）的算法中，快慢指针的起点是可以根据具体问题的需求来设置的。虽然在很多经典问题中，快慢指针通常从同一个起点出发，但在某些情况下，让它们从不同的起点出发也是完全可行的，甚至可能更符合问题的需求。
快慢指针的基本概念
快慢指针是一种常用的算法技巧，通常用于解决以下几类问题：
检测链表中的环：通过快指针（每次移动两步）和慢指针（每次移动一步）来判断是否存在环。
寻找环的入口：在检测到环之后，通过调整指针的起点和移动速度来找到环的入口。
寻找数组或链表中的特定位置：例如，寻找链表的中点、寻找第 k 个节点等。
快慢指针从不同起点出发的场景
1. 寻找环的入口
在链表中检测环并找到环的入口时，快慢指针会从不同起点出发：
初始阶段：快慢指针从同一个起点出发，用于检测是否存在环。
找到环之后：将一个指针移动到链表的头节点，另一个指针保持在相遇点，然后两个指针以相同速度移动，最终会在环的入口处相遇。
[环形链表](../链表/环形链表.md)
```cpp
ListNode* detectCycle(ListNode* head) {
    if (!head || !head->next) return nullptr;

    ListNode* slow = head;
    ListNode* fast = head;

    // 检测是否存在环
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            break; // 发现环
        }
    }

    // 如果没有环，返回 nullptr
    if (!fast || !fast->next) return nullptr;

    // 找到环的入口
    slow = head; // 将 slow 指针移动到头节点
    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }

    return slow; // slow 和 fast 在环的入口处相遇
}
```
2. 寻找数组中的特定元素
在某些数组问题中，快慢指针也可以从不同起点出发。例如，在寻找数组中的某个特定位置或满足特定条件的元素时，可以根据问题的性质设置不同的起点。
示例问题：在一个旋转排序数组中找到最小值。
问题描述：给定一个旋转排序数组（例如 [4, 5, 6, 7, 0, 1, 2]），找到数组中的最小值。
解决方案：可以使用快慢指针，但这里的“快慢”更多体现在移动策略上，而不是速度。快指针可以用于快速跳过某些区域，慢指针用于逐步逼近。
示例代码：
```cpp
int findMin(vector<int>& nums) {
    int left = 0, right = nums.size() - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[right]) {
            left = mid + 1; // 最小值在右半部分
        } else {
            right = mid; // 最小值在左半部分或就是 mid
        }
    }

    return nums[left]; // 最终 left 和 right 会指向最小值
}
```
在这个例子中，虽然不是传统的快慢指针，但通过调整指针的移动策略，可以高效地解决问题。


### 左右指针
左右指针是指两个指针分别从两端出发，但是一个指针每次走一步，另一个指针每次走两步。这种指针的应用场景有很多，比如判断一个字符串是否是回文串，判断一个字符串是否频率相同等等。


[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/?envType=study-plan-v2&envId=top-interview-150)

利用模拟指针的方法来写。

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int src=0,dst=0;
        while(src<nums.size()){
            if(nums[src]==val){
                src++;
            }else{
                nums[dst++]=nums[src++];
            }
        }
        return dst;
    }
};
```

删除有序数组中的重复项

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int sz=nums.size();
        if(sz==0){
            return 0;
        }
        int fast=1,slow=1;
        while(fast<sz){
            if(nums[fast]!=nums[fast-1]){
                nums[slow++]=nums[fast];
            }
            fast++;
        }
        return slow;
    }
};
```

### 滑动窗口
滑动窗口是一种常用的算法技巧，主要用于解决数组或字符串中的子数组或子串问题。通过维护一个窗口的左右边界，滑动窗口可以在一次遍历中高效地解决问题，避免了暴力解法中重复计算的问题。以下是滑动窗口相关的知识和常见应用场景：
1. 滑动窗口的基本概念
窗口：一个连续的子数组或子串，窗口的左右边界可以动态调整。
窗口的大小：窗口的长度，即右边界与左边界之间的距离。
窗口的滑动：通过移动窗口的左右边界，改变窗口的位置或大小。
2. 滑动窗口的类型
    1. 固定大小的滑动窗口
    应用场景：需要处理固定长度的子数组或子串。
    示例：找出一个数组中长度为 k 的子数组的最大和。
    解法：初始化一个窗口，计算窗口内的和，然后滑动窗口并更新最大和。
    代码示例：
    ```cpp
    int maxSubarraySum(std::vector<int>& nums, int k) {
        int n = nums.size();
        int max_sum = 0;
        int window_sum = 0;

        for (int i = 0; i < k; ++i) {
            window_sum += nums[i];
        }
        max_sum = window_sum;

        for (int i = k; i < n; ++i) {
            window_sum += nums[i] - nums[i - k];
            max_sum = std::max(max_sum, window_sum);
        }

        return max_sum;
    }
    ```
    2. 动态大小的滑动窗口
    应用场景：需要处理满足特定条件的最短或最长子数组或子串。
    示例：找出一个字符串中包含所有字符的最短子串。
    解法：使用两个指针表示窗口的左右边界，动态调整窗口大小，直到满足条件。
    代码示例：
    ```cpp
    std::string minWindowSubstring(std::string s, std::string t) {
        std::unordered_map<char, int> need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0;
        int start = 0, len = INT_MAX;

        while (right < s.size()) {
            char c = s[right];
            right++;
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c]) valid++;
            }

            while (valid == need.size()) {
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                char d = s[left];
                left++;
                if (need.count(d)) {
                    if (window[d] == need[d]) valid--;
                    window[d]--;
                }
            }
        }

        return len == INT_MAX ? "" : s.substr(start, len);
    }
    ```
3. 滑动窗口的常见应用场景
    1. 最大子数组和
    问题：找出一个数组中长度为 k 的子数组的最大和。
    解法：固定大小的滑动窗口。
    2. 最小覆盖子串
    问题：找出一个字符串中包含所有目标字符的最短子串。
    解法：动态大小的滑动窗口。
    3. 无重复字符的最长子串
    问题：找出一个字符串中不包含重复字符的最长子串。
    解法：动态大小的滑动窗口。
    代码示例：
    ```cpp
    int lengthOfLongestSubstring(std::string s) {
        std::unordered_map<char, int> window;
        int left = 0, right = 0;
        int max_len = 0;

        while (right < s.size()) {
            char c = s[right];
            right++;
            window[c]++;

            while (window[c] > 1) {
                char d = s[left];
                left++;
                window[d]--;
            }

            max_len = std::max(max_len, right - left);
        }

        return max_len;
    }
    ```
    4. 水果成篮
    问题：在一个数组中，最多包含两种不同元素的最长子数组。
    解法：动态大小的滑动窗口。
    代码示例：
    ```cpp
    int totalFruit(std::vector<int>& fruits) {
        std::unordered_map<int, int> window;
        int left = 0, right = 0;
        int max_len = 0;

        while (right < fruits.size()) {
            int c = fruits[right];
            right++;
            window[c]++;

            while (window.size() > 2) {
                int d = fruits[left];
                left++;
                window[d]--;
                if (window[d] == 0) window.erase(d);
            }

            max_len = std::max(max_len, right - left);
        }

        return max_len;
    }
    ```
4. 滑动窗口的优化技巧
双指针：使用两个指针表示窗口的左右边界，通过移动指针来调整窗口大小。
哈希表：使用哈希表（如 unordered_map）来记录窗口内的字符或元素频次，便于快速判断是否满足条件。
贪心思想：在满足条件的情况下，尽量缩小窗口，以找到最短的子串或子数组。
5. 滑动窗口的时间复杂度
固定大小的滑动窗口：时间复杂度为 O(n)，因为每个元素最多被访问两次（一次加入窗口，一次移出窗口）。
动态大小的滑动窗口：时间复杂度也为 O(n)，虽然窗口的大小会动态变化，但每个元素仍然最多被访问两次。
6. 滑动窗口的注意事项
边界条件：确保窗口的左右边界不会越界。
窗口内条件：在调整窗口大小时，确保窗口内的元素满足条件。
特殊情况：如输入为空或目标条件无法满足时，需要提前处理。
通过掌握滑动窗口的技巧，可以高效地解决许多数组和字符串相关的算法问题。